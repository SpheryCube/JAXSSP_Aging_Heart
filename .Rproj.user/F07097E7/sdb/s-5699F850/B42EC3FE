{
    "collab_server" : "",
    "contents" : "# Look at eQTL and pQTL hotspots for DO cross sectional heart data.\n# Create QTL density plot functions and QTL maps\n# R/3.4.4\n# Daniel Alfonsetti\n# daniel.alfonsetti@gmail.com\n# Jul. 20, 2018\n################################################################################\n#######################\n# Reset environment\nrm(list = ls())\n\nlibrary(qtl2)\nlibrary(broom)\nlibrary(RColorBrewer)\nlibrary(doParallel)\nlibrary(pcaMethods)\n\nlibrary(\"org.Mm.eg.db\")  # Mouse data base\nlibrary(tidyverse) # Contains ggplot2, dplyr, stringr and some other stuff\n\n# Enrichment analysis libraries\nlibrary(allez)  \nlibrary(clusterProfiler)\n\n######## Local directories\nnum_cores <- 3\n\n# Input paths\npeaks_tables_dir <- \"~/do_heart/results/\"\nperms_input_dir <- \"~/do_heart/results/\"\n\n# Output paths\n# fig_output_dir <- \"~/do_heart/results/plots/\"\nbase_output_dir <- \"~/do_heart/results/\"\nload(\"~/do_heart/data/cleaned_data.RData\")\n######## HPC directories\n# num_cores <- 30\n# # \n# # Input paths\n# peaks_tables_dir <- \"/home/c-alfond/do_heart/results/\"\n# perms_input_dir <- \"/home/c-alfond/do_heart/results/\"\n# \n# # Output paths\n# # fig_output_dir <- \"/home/c-alfond/do_heart/results/plots/\"\n# base_output_dir <- \"/home/c-alfond/do_heart/results/\"\n# load(\"/home/c-alfond/do_heart/data/cleaned_data.RData\")\n##########################################################\n# Register parallele back end.\nregisterDoParallel(cores = num_cores)\n##########################################################\n# Helper functions\n\n# Yuka Takemon and Dan Gatti's QTL scatterplot function\n# Arguments:\n# data: data.frame (or tibble) with the following columns:\n#       ensembl: (required) character string containing the Ensembl gene ID.\n#       qtl_chr: (required) character string containing QTL chromsome.\n#       qtl_pos: (required) floating point number containing the QTL position \n#                in Mb.\n#       qtl_lod: (optional) floating point number containing the LOD score.\n#       gene_chr:  (optional) character string containing transcript chromosome.\n#       gene_start: (optional) character string containing transcript start \n#                 postion in Mb.\n#       gene_end:  (optional) character string containing transcript end\n#                position in Mb.\n# color.points: logical that is TRUE if the points should be colored by LOD.\n# cis.points: logical that is TRUE if the points should be colored if they\n#             are with in cis.\n# cis.radius: numeric value containing the radius in Mb between a gene and a cis-eQTL.\n#             Optional.\n# cis.color: color for cis QTL. Optional.\n# Returns:\n# a plot of the QTL and gene location for each gene.\n\nggQTLmap = function(data, title, color.points = FALSE, cis.points = FALSE, cis.radius = 2, \n                    cis.color = \"#4286f4\") {\n  \n  \n  # Check for required column names.\n  required.colnames = c(\"ensembl\", \"qtl_chr\", \"qtl_pos\")\n  \n  if(all(!required.colnames %in% colnames(data))) {\n    stop(paste(\"colnames must contain the following columns:\", \n               paste(required.colnames, collapse = \",\")))\n  } # if(!required.colnames %in% colnames(data))\n  \n  # Make sure that columns are not factors.\n  data$ensembl = as.character(data$ensembl)\n  data$qtl_chr = as.character(data$qtl_chr)\n  \n  gene.position.colnames = c(\"gene_chr\", \"gene_start\", \"gene_end\")\n  if(!all(gene.position.colnames %in% colnames(data))) {\n    \n    message(paste(\"Using Ensembl gene locations because optional gene\",\n                  \"position columns (\", paste0(gene.position.colnames, collapse = \",\"),\n                  \") not found.\"))\n    \n    # Get the latest Ensembl GTF.\n    ensembl = get_ensembl_genes()\n    \n    id    = ensembl$gene_id\n    chr   = seqnames(ensembl)\n    start = start(ensembl) * 1e-6\n    end   = end(ensembl)   * 1e-6\n    \n    df = data.frame(ensembl = id, gene_chr = chr, gene_start = start, gene_end = end,\n                    stringsAsFactors = F)\n    data = left_join(data, df, by = \"ensembl\")\n    \n  } # if(gene.position.colnames %in% colnames(data))\n  \n  # Make sure that columns are not factors.\n  data$gene_chr = as.character(data$gene_chr)\n  \n  # Get the gene mid-point.\n  data = data %>% mutate(gene_pos = (gene_end + gene_start) * 0.5)\n  \n  # Fix the factor levels for the chr.\n  all.chr = data %>% select(qtl_chr, gene_chr) %>%\n    gather(k, v) %>%\n    select(v) %>%\n    distinct() %>%\n    arrange(v)\n  all.chr = all.chr$v[!is.na(all.chr$v)]\n  \n  if(length(grep(\"M\", all.chr)) > 0) {\n    wh = grep(\"M\", all.chr)\n    all.chr = all.chr[c(1:(wh-1), (wh+1):length(all.chr), wh)]\n  }\n  \n  # Remove any NAs.\n  data = data %>% na.omit\n  \n  data$qtl_chr  = factor(data$qtl_chr,  levels = all.chr[order(as.numeric(all.chr))])\n  data$gene_chr = factor(data$gene_chr, levels = rev(all.chr[order(as.numeric(all.chr))]))\n  \n  # If we're plotting cis points, then add a cis-QTL column.\n  if(cis.points) {\n    \n    data = data %>% mutate(cis = (gene_chr == qtl_chr) & (abs(gene_pos - qtl_pos) <= cis.radius))\n    cis.colors = c(\"black\", cis.color)\n    names(cis.colors) = c(\"FALSE\", \"TRUE\")\n    out.plot <- ggplot(data, aes(x = qtl_pos, y = gene_pos)) +\n      geom_point(aes(color = cis), alpha = 0.5) + \n      scale_color_manual(values = cis.colors) +\n      facet_grid(gene_chr ~ qtl_chr, scales = \"free\", shrink = TRUE, drop = FALSE) +\n      theme(panel.background = element_blank(),\n            panel.border = element_rect(fill = 0, color = \"grey70\"),\n            panel.grid.minor = element_blank(),\n            panel.spacing = unit(0.05, \"lines\"),\n            axis.text.x = element_text(angle = 90, hjust = 1)) +\n      ggtitle(title)\n    \n  } else { \n    \n    out.plot <- ggplot(data, aes(x = qtl_pos, y = gene_pos)) +\n      geom_point(aes(color = qtl_lod, alpha = 0.5)) + {\n        if(color.points) scale_color_continuous(low = \"grey50\", high = \"red\") \n      } +\n      facet_grid(gene_chr ~ qtl_chr, scales = \"free\", shrink = TRUE, drop = FALSE) +\n      theme(panel.background = element_blank(),\n            panel.border = element_rect(fill = 0, color = \"grey70\"),\n            panel.grid.minor = element_blank(),\n            panel.spacing = unit(0.05, \"lines\"),\n            axis.text.x = element_text(angle = 90, hjust = 1)) + \n      ggtitle(title)\n  } # else\n  print(out.plot)\n} # ggtmap()\n\n# Dan Gatti's QTL Density Plot function\nqtl_density_func <- function(peaks_table, lod_threshold, cis_boolean, expr_type, covar_name, test_type, create_file = TRUE) {\n  \n  # Window 4Mb, slide it in 1Mb steps.\n  breaks = matrix(c(seq(0, 200, 4), seq(1, 201, 4), seq(2, 202, 4), seq(3, 203, 4)), ncol = 4)\n  tmp = as.list(1:ncol(breaks)) \n  for(i in 1:ncol(breaks)) {\n    tmp[[i]] = peaks_table %>%\n      filter(qtl_lod >= lod_threshold & cis == cis_boolean) %>% \n      arrange(qtl_chr, qtl_pos) %>%\n      group_by(qtl_chr) %>%\n      mutate(win = cut(qtl_pos, breaks = breaks[,i])) %>%\n      group_by(qtl_chr, win) %>% \n      summarize(cnt = n()) %>%\n      separate(win, into =  c(\"placeholder\", \"prox\", \"dist\")) %>%\n      mutate(prox = as.numeric(prox), \n             dist = as.numeric(dist), \n             mid = 0.5 * (prox + dist)) %>%\n      select(qtl_chr, mid, cnt)\n  }\n  \n  result = bind_rows(tmp[[1]], tmp[[1]], tmp[[3]], tmp[[4]])\n  rm(tmp)\n  \n  \n  if (cis_boolean & expr_type == \"mrna\") {\n    plot_title <- paste0(\"cis-eQTL Density Histogram (Interactive Covariate=\", covar_name, \")\"); \n    file_name <- \"cis_eqtl_density_hist.pdf\"}\n  else if (cis_boolean & expr_type == \"protein\") {\n    plot_title <- paste0(\"cis-pQTL Density Histogram (Interactive Covariate=\", covar_name, \")\"); \n    file_name <- \"cis_pqtl_density_hist.pdf\"}\n  else if(!cis_boolean & expr_type == \"mrna\") {\n    plot_title <- paste0(\"trans-eQTL Density Histogram (Interactive Covariate=\", covar_name, \")\"); \n    file_name <- \"trans_eqtl_density_hist.pdf\"}\n  else {\n    plot_title <- paste0(\"trans-pQTL Density Histogram (Interactive Covariate=\", covar_name, \")\"); \n    file_name <- \"trans_pqtl_density_hist.pdf\"}\n  \n  \n  # Make plot\n  out.plot = ggplot(result, aes(mid, cnt, color = cnt)) +\n    geom_line() +\n    scale_color_gradient(low = \"#32b72d\", high = \"#af33c6\") + \n    # scale_color_gradient(low = \"#32aeff\", high = \"#f2aeff\") + \n    facet_grid(.~qtl_chr, scales = \"free\") +\n    theme_light() +\n    theme(panel.background = element_blank(),\n          panel.border = element_rect(fill = 0, color = \"grey70\"),\n          panel.spacing = unit(0, \"lines\"),\n          axis.text.x = element_text(angle = 90),\n          panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +\n    labs(title = plot_title, x = \"Mb\", y = \"Number of QTLs\")\n  \n  if (create_file) {\n    file_name <- paste0(test_type,\"_\", file_name)\n    pdf(paste0(output_dir, file_name), width = 10, height = 8)\n    print(out.plot)\n    dev.off()\n  } else {\n    print(out.plot)\n  }\n  return(result)\n}\n\n\n# qtl_type: is in reference to the qtl location. 'cis' vs 'trans'\n# scan_type: is in reference to the model and expression data used. \n# For example, 'protein_age' means the QTLs are pQTLs where age was an interactive covariate.\n# expr_to_plot: Either 'mrna' or 'protein'. If we have eQTL data and we want to plot protein,\n# the function will plot proteins that correspond to the genes in the eQTL data. Vice versa\n# if we have pQTL data and we want to plot their transcript correlations.\n\nhotspot_correlations <- function(hotspot.genes, qtl_type, expr_to_plot = \"mrna\", test_type){\n  \n  # Hotspot correlations\n  breaks = -100:100/100\n  colors = colorRampPalette(rev(brewer.pal(11, \"Spectral\")))(length(breaks) - 1)\n  \n  file_name <-  paste0(test_type, \"_\", qtl_type, \"_qtl_gene_hotspot_\", expr_to_plot, \"_correlations.pdf\")\n  pdf(paste0(output_dir, file_name), width = 10, height = 10)\n  \n  for(i in 1:length(hotspot.genes)) {\n    chr = names(hotspot.genes)[i]\n    \n    if (length(hotspot.genes[[i]]$lodcolumn) == 1) {next} # Can't do correlations if there is only one gene in hotspot.\n    \n    if (expr_to_plot == \"protein\") { # plot protein-protein correlations for genes in the hotspot\n      \n      # If the lod peaks are for genes and we want to plot the correlations between those genes' corresponding proteins\n      if (grepl(\"mrna\", test_type)) {\n        \n        # Get the corresponding protein ids and then plot. For each protein id, record the qtl score\n        # of the gene that mapped to it so that we can color the protein ids on the heatmap.\n        # Note: we don't have protein data that corresponds to every mrna. Therefore we will just skip \n        # those that don't have corresponding mrna.\n        df <- data.frame(matrix(nrow = 0, ncol = 2))\n        colnames(df) <- c(\"protein_id\", \"corresponding_gene_qtl\")\n        for (j in 1:nrow(hotspot.genes[[i]])) { # for each gene...\n          cur_gene_id <- hotspot.genes[[i]][j,]$lodcolumn\n          cur_gene_qtlscore <- hotspot.genes[[i]][j,]$qtl_lod\n          protein_ids <- annot.protein %>% filter(gene_id == cur_gene_id)  %>% select(protein_id)\n          if (nrow(protein_ids) == 0) {next}\n          for (k in 1:nrow(protein_ids)) # For each protein that this gene maps to...\n          {\n            protein_id <- protein_ids$protein_id[k]\n            df[nrow(df)+1,] <- c(protein_id, cur_gene_qtlscore)\n          } #for(k)\n        } #for(j)\n        df$corresponding_gene_qtl <- as.numeric(df$corresponding_gene_qtl)\n        df <- df[!duplicated(df$protein_id),] # Get rid of repeats. There might be repeats since some genes can map to the same protein.\n        if (nrow(df) == 0) {next} # Make sure we aren't empty now.\n        side.colors = cut(df$corresponding_gene_qtl, breaks = 100)\n        \n        # make correlations matrix now.\n        \n        # Not all gene ids have corresponding proteins, so only get the genes that do.\n        protein_ids <- annot.protein %>% filter(gene_id %in% hotspot.genes[[i]]$lodcolumn) %>% select(protein_id)\n        protein_ids <- unlist(protein_ids)\n        expr.data <- expr.protein[, protein_ids]\n        if(length(expr.data) == 189) {next} # If we only have one viable protein, we can't plot anything.\n        tmp <- cor(expr.data,  use = \"pairwise.complete.obs\")\n        dimnames(tmp) = list(protein_ids, protein_ids)\n        \n        # If the lod peaks are for proteins and we want to plot protein correlation...\n      } else { \n        \n        expr.data <- expr.protein[, hotspot.genes[[i]]$lodcolumn]\n        tmp <- cor(expr.data,  use = \"pairwise.complete.obs\")\n        dimnames(tmp) = list(hotspot.genes[[i]]$lodcolumn, hotspot.genes[[i]]$lodcolumn)\n        side.colors = cut(hotspot.genes[[i]]$qtl_lod, breaks = 100)\n        \n      }\n      \n    } else { # We want to plot mrna - mrna correlations for genes in the hotspot\n      \n      # If the lod peaks are for genes and we want to plot gene correlations...\n      if (grepl(\"mrna\", test_type)) { \n        \n        expr.data <- expr.mrna[, hotspot.genes[[i]]$lodcolumn]\n        tmp <- cor(expr.data,  use = \"pairwise.complete.obs\")\n        dimnames(tmp) = list(hotspot.genes[[i]]$lodcolumn, hotspot.genes[[i]]$lodcolumn)\n        # side.colors = cut(hotspot.genes[[i]]$qtl_lod, breaks = 100)\n        side.colors = cut(hotspot.genes[[i]]$qtl_lod, breaks = 100)\n        \n        # If the lod peaks are for proteins and we want to plot mrna-mrna correlations...\n      } else { \n        \n        # Get the corresponding gene ids and then plot \n        expr.data <- expr.mrna[, hotspot.genes[[i]]$gene_id]\n        tmp <- cor(expr.data,  use = \"pairwise.complete.obs\")\n        dimnames(tmp) = list(hotspot.genes[[i]]$gene_id, hotspot.genes[[i]]$gene_id)\n        side.colors = cut(hotspot.genes[[i]]$qtl_lod, breaks = 100)\n      }\n    }\n    \n    # Make heatmap\n    if (grepl(\"mrna\", test_type)) {\n      plot_title <- paste0(qtl_type, \" eQTLs Chr\", chr, \" Gene Hotspot \", expr_to_plot, \" Correlations\")\n    } else {\n      plot_title <- paste0(qtl_type, \" pQTLs Chr\", chr, \" Gene Hotspot \", expr_to_plot, \" Correlations\")\n    }\n    \n    side.colors = colorRampPalette(rev(brewer.pal(9, \"YlOrRd\")))(length(levels(side.colors)))[as.numeric(side.colors)]\n    names(side.colors) = rownames(tmp)\n    \n    heatmap(tmp, symm = TRUE, scale = \"none\", main = plot_title,\n            breaks = breaks, col = colors, RowSideColors = side.colors, ColSideColors = side.colors)\n  }\n  dev.off()\n}\n\n\nget_hotspots_genes_func <- function(hotspots, qtl_type, lod_threshold, test_type) {\n  \n  hotspots_genes = as.list(hotspots$qtl_chr)\n  names(hotspots_genes) = hotspots$qtl_chr\n  \n  if (grepl(\"protein\", test_type)) {expr.data <- expr.protein\n  } else {expr.data <- expr.mrna}\n  \n  \n  for(i in 1:nrow(hotspots)) {\n    \n    if (qtl_type == \"trans\") {\n      hotspots_genes[[i]] = peaks_table %>% \n        filter(qtl_lod >= lod_threshold) %>%\n        filter(qtl_chr == hotspots$qtl_chr[i] & \n                 qtl_pos >= hotspots$proximal[i] & \n                 qtl_pos <= hotspots$distal[i]) %>%\n        filter(cis == FALSE)\n    } else {\n      hotspots_genes[[i]] = peaks_table %>% \n        filter(qtl_lod >= lod_threshold) %>%\n        filter(qtl_chr == hotspots$qtl_chr[i] & \n                 qtl_pos >= hotspots$proximal[i] & \n                 qtl_pos <= hotspots$distal[i]) %>%\n        filter(cis == TRUE)\n    }\n    \n    \n    if (nrow(hotspots_genes[[i]]) == 0) {next}\n    # Append current gene's expression data to the row.\n    hotspots_genes[[i]][, rownames(expr.data)] <- NA\n    for (j in 1:nrow(hotspots_genes[[i]])) {\n      ensembl_id <- hotspots_genes[[i]]$lodcolumn[j]\n      hotspots_genes[[i]][j, rownames(expr.data)] <- expr.data[,ensembl_id]\n    } # for(i)\n    write_csv(hotspots_genes[[i]], path = paste0(output_dir, test_type, \"_\", qtl_type, \"_chr\", names(hotspots_genes)[i], \"_hotspot_genes.csv\"))\n  } # for(j)\n  return(hotspots_genes)\n} #get_hotspots_genes_func\n\n\nallez_helper_func <- function(allez_table) {\n  # Description: Takes a table from the output of the allez function and adds columns that contain gene symbols and ensembl ids \n  # corresponding to the set of entrenz gene ids in a given row (category)\n  ####\n  \n  # Convert entrenz gene ids into ensemble gene ids and gene symbols\n  allez_table[, c(\"ensembl_ids\", \"symbols\")] <- NA\n  names(allez_table)[names(allez_table) == \"genes\"] <- \"entrenz_ids\"\n  \n  # Iterate over each row (category) and update them (add gene ids and gene symbols)\n  for (i in 1:nrow(allez_table)) {\n    # i = 1\n    row <- allez_table[i,]\n    row$entrenz_ids <- gsub(\";\", \",\", row$entrenz_ids)\n    \n    entrenz_ids <- strsplit(row$entrenz_ids, \",\")[[1]] \n    \n    #result <- select(org.Mm.eg.db, entrenz_ids, c(\"SYMBOL\", \"GENENAME\"), \"ALIAS\")\n    result <- AnnotationDbi::select(org.Mm.eg.db, \n                                    keys= as.character(as.matrix(entrenz_ids)), \n                                    columns=c(\"SYMBOL\", \"ENSEMBL\"), \n                                    keytype=\"ENTREZID\")\n    result <- result[!is.na(result$ENTREZID),]\n    \n    row$ensembl_ids <-  paste0(result$ENSEMBL, collapse = \",\")\n    row$symbols <- paste0(result$SYMBOL, collapse = \",\")\n    allez_table[i,] <- row\n  }\n  \n  allez_table <- allez_table[order(allez_table[,'z.score'], decreasing = TRUE),] # Sort by z-score\n  return(allez_table)\n}\n\n# End of helper functions\n#####################\n#####################\n#########################################################################################################\n#########################################################################################################\n#########################################################################################################\n\n\noutput_dir <- paste0(base_output_dir, \"preliminary_hotspot_results/\")\ndir.create(output_dir)\nsetwd(output_dir)\n\n# Iterate over each test type\npeaks_files <- Sys.glob(paste0(peaks_tables_dir, \"*peaks*thresh_6*\")) # contains the full path\n\n\npdf(\"preliminary_hotspot_results.pdf\")\nfor (test_type in c(\"mrna_sex\", \"mrna_age\", \"mrna_none\", \"protein_sex\", \"protein_age\", \"protein_none\")) {\n  \n  # Set some parameters\n  if (grepl(\"protein\", test_type)) {expr_type = \"protein\"} else {expr_type = \"mrna\"}\n  if (grepl(\"age\", test_type)) {covar_name = \"Age\"} else if (grepl(\"sex\", test_type)) {covar_name = \"Sex\"} else {covar_name = \"None\"}\n  \n  \n  # Read in peaks table\n  file <- peaks_files[grepl(test_type, peaks_files)]\n  peaks_table <- read.csv(file, stringsAsFactors = TRUE)\n  levels = c(1:19, \"X\", \"Y\", \"M\")\n  peaks_table$gene_chr <- factor(peaks_table$gene_chr, levels = levels)\n  peaks_table$qtl_chr <- factor(peaks_table$qtl_chr, levels = levels)\n  \n  \n  # Filter out genes with qtl's less than the 95 % of distribution maximum LODs\n  # of 10000 permutations\n  # Get current test types' corresponding set of permutations.\n  perm_file_name <- paste0(\"perms_\", test_type, \".rds\")\n  perms <- readRDS(paste0(perms_input_dir, perm_file_name))\n  \n  lod_threshold <- summary(perms)[,'pheno1'] # 95 percentile\n  # lod_threshold <- 6\n  peaks_table <- peaks_table %>% filter(qtl_lod > lod_threshold)\n  \n  ###########################################################################\n  # Create and save QTL map\n  if (expr_type == \"mrna\") { \n    df <- rename(peaks_table, ensembl = lodcolumn)\n    title <- paste0(\"eQTL Map (Interactive Covariate = \", covar_name, \")\")\n  } else { \n    title <- paste0(\"pQTL Map (Interactive Covariate = \", covar_name, \")\")\n    df <- rename(peaks_table,ensembl = lodcolumn) \n  }\n  ggQTLmap(data = df, title = title, color.points = FALSE, cis.points = TRUE, cis.radius = 2, \n           cis.color = \"#4286f4\")\n  ###########################################################################\n  # Create and save density histograms\n  for (qtl_type in c(\"cis\", \"trans\")) {\n    cis_boolean <- grepl(\"cis\", qtl_type)\n    qtl_density_result <- qtl_density_func(peaks_table, lod_threshold = lod_threshold, cis_boolean = cis_boolean, \n                                           expr_type = expr_type, covar_name = covar_name, test_type = test_type, create_file = FALSE)\n  }\n}\ndev.off()\n\n#########################################################################################################\n#########################################################################################################\n#########################################################################################################\n#########################################################################################################\n# Manually set threshold for number of counts in a hotspot for each test type based on qtl density histograms\n# made above. Each test vector is of the following form:\n# c(\"TEST_TYPE_NAME\", \"CIS_HOTSPOT_CNT_THRESHOLD\", \"TRANS_HOTSPOT_CNT_THRESHOLD\")\n\n\ntests <- list(c(\"mrna_sex\",60,60),  c(\"mrna_age\",60,40), c(\"mrna_none\",75,80),\n              c(\"protein_sex\", 7, 7), c(\"protein_age\",8,8), c(\"protein_none\",8,8))\n\n\n\n# Iterate over each test. For each hotspot get hotspot genes,\n# make principle component plots, and do enrichment analysis\nfor (test_params in tests) {\n  \n  print(test_params)\n  test_type <- test_params[1]\n  if (grepl(\"protein\", test_type)) {expr_type = \"protein\"} else {expr_type = \"mrna\"}\n  if (grepl(\"age\", test_type)) {covar_name = \"Age\"} else if (grepl(\"sex\", test_type)) {covar_name = \"Sex\"} else {covar_name = \"None\"}\n  \n  \n  file <- peaks_files[grepl(test_type, peaks_files)]\n  dir.create(paste0(base_output_dir, test_type, \"_hotspots_output/\"))\n  output_dir <- paste0(base_output_dir, test_type, \"_hotspots_output/\")\n  setwd(output_dir)\n  \n  # Read in peaks table\n  peaks_table <- read.csv(file, stringsAsFactors = TRUE)\n  levels = c(1:19, \"X\", \"Y\", \"M\")\n  peaks_table$gene_chr <- factor(peaks_table$gene_chr, levels = levels)\n  peaks_table$qtl_chr <- factor(peaks_table$qtl_chr, levels = levels)\n  \n  \n  # Filter out genes with qtl's less than the 95 % of distribution maximum LODs\n  # of 10000 permutations\n  # Get current test types' corresponding set of permutations.\n  perm_file_name <- paste0(\"perms_\", test_type, \".rds\")\n  perms <- readRDS(paste0(perms_input_dir, perm_file_name))\n  \n  lod_threshold <- summary(perms)[,'pheno1'] # 95 percentile\n  # lod_threshold <- 6\n  peaks_table <- peaks_table %>% filter(qtl_lod > lod_threshold)\n  \n  ###########################################################################\n  # Create and save QTL map\n  pdf(paste0(test_type, \"_QTLmap.pdf\"))\n  if (expr_type == \"mrna\") { \n    df <- rename(peaks_table, ensembl = lodcolumn)\n    title <- paste0(\"eQTL Map (Interactive Covariate = \", covar_name, \")\")\n  } else { \n    title <- paste0(\"pQTL Map (Interactive Covariate = \", covar_name, \")\")\n    df <- rename(peaks_table,ensembl = lodcolumn) \n  }\n  ggQTLmap(data = df, title = title, color.points = FALSE, cis.points = TRUE, cis.radius = 2, \n           cis.color = \"#4286f4\")\n  dev.off()\n  ###########################################################################\n  \n  # Stratify by QTL position type.\n  for (qtl_type in c(\"cis\", \"trans\")) {\n    print(paste0(\"QTL type \", qtl_type))\n    \n    \n    ###########################################################################\n    # Create and save density histograms\n    cis_boolean <- grepl(\"cis\", qtl_type)\n    qtl_density_result <- qtl_density_func(peaks_table, lod_threshold = lod_threshold, cis_boolean = cis_boolean, \n                                           expr_type = expr_type, covar_name = covar_name, test_type = test_type, create_file = TRUE)\n    ###########################################################################\n    \n    # Pull out hotspot count threshold for this type.\n    if (grepl(\"cis\", qtl_type)) {hotspot_cnt_thresh <- as.integer(test_params[2])} else\n    {hotspot_cnt_thresh <- as.integer(test_params[3])}\n    \n    if (grepl(\"protein\", test_type)) {expr_type = \"protein\"} else {expr_type = \"mrna\"}\n    if (grepl(\"age\", test_type)) {covar_name = \"Age\"} else if (grepl(\"sex\", test_type)) {covar_name = \"Sex\"} else {covar_name = \"None\"}\n    \n    ###########################################################################\n    ###########################################################################\n    # Get hotspots (i.e. genome intervals of 4 Mb with more than 'hotspot_cnt_thresh' number\n    # of QTLs)\n    \n    # Thing to note: Some tests may have chromosomes with multiple hotspots. This results in a problem.\n    # One possible solution: only take the bigger of the two for now. \n    # (or largest out of all of them if there are multiple hotspots per chromosomes)\n    hotspots = qtl_density_result %>%\n      group_by(qtl_chr) %>%\n      filter(cnt == max(cnt)) %>%\n      filter(cnt > hotspot_cnt_thresh) %>%\n      distinct()\n    \n    # If there are two hotspots taht share a maximum count, get rid of one of them.\n    hotspots <- hotspots[!duplicated(hotspots$qtl_chr),]\n    hotspots = hotspots %>%\n      summarize(center = median(mid)) %>%\n      mutate(proximal = center - 2, distal = center + 2)\n    \n    if (nrow(hotspots) == 0) {next}\n    \n    # Given the hotspot locations, retain all genes with LOD > threshold\n    # and QTL within +/- 4Mb of the mid-point of the hotspot.\n    # Returns a list of dataframes, one for each hotspot.\n    # Rows of the dataframe contain gene information.\n    hotspots_genes <- get_hotspots_genes_func(hotspots, qtl_type, lod_threshold, test_type) \n    \n    # Number of genes in each hotspot.\n    hotspots = data.frame(hotspots, count = sapply(hotspots_genes, nrow))\n    # kable(hotspots, caption = \"Number of genes per hotspot\")\n    \n    ###########################################################################\n    ###########################################################################\n    # Make plots of correlations between genes in hotspots.\n    print(\"Making hotspot correlation heatmaps...\")\n    # 1. Plot correlations between their transcipts.\n    hotspot_correlations(hotspots_genes, qtl_type = qtl_type, \n                         expr_to_plot = \"mrna\", test_type = test_type)\n    # 2. Plot those gene's corresponding proteins if they have them.\n    hotspot_correlations(hotspots_genes, qtl_type = qtl_type, \n                         expr_to_plot = \"protein\", test_type = test_type)\n    \n    \n    ###########################################################################\n    ###########################################################################\n    # Make Principle components\n    print(\"Performing principle component analysis...\")\n    \n    hotspots_pcs = as.list(names(hotspots_genes))\n    names(hotspots_pcs) = names(hotspots_genes)\n    \n    pdf(paste0(test_type, \"_\", qtl_type, \"_hotspot_pcs.pdf\"), width = 10, height = 8)\n    for(i in 1:length(hotspots_genes)) {\n      tmp = hotspots_genes[[i]] %>%\n        select(starts_with(\"DO\")) %>%\n        as.matrix() %>%\n        t() %>%\n        pca(method = \"svdImpute\", nPcs = 3)\n      \n      hotspots_pcs[[i]] = scores(tmp)\n      tmp = gather(data.frame(Mouse.ID = rownames(hotspots_pcs[[i]]), hotspots_pcs[[i]]), key = pc, value = value, -Mouse.ID)\n      tmp = left_join(tmp, annot.sample %>% select(Mouse.ID, Age, Sex), by = \"Mouse.ID\")\n      print(tmp %>%\n              filter(pc %in% paste0(\"PC\", 1:3)) %>%\n              mutate(Age = factor(Age)) %>%\n              ggplot(aes(x = Age, value, fill = Sex)) +\n              geom_boxplot() +\n              facet_grid(pc~.) +\n              theme_linedraw() +\n              labs(title = paste(\"Chr\", names(hotspots_genes)[i], \"Hotspot\")))\n    }\n    dev.off()\n    \n    ###########################################################################\n    ###########################################################################\n    # Get enriched gene categories for each hotspot. First get the data we are using.\n    \n    # Pull out data for current expression type.\n    # Get type of data. Store column symbols in last row.\n    if (grepl(\"mrna\", test_type)) { \n      expr.data <- expr.mrna\n      expr.data <- rbind(expr.data, annot.mrna$symbol)\n      annot.data <- annot.mrna \n    } else { \n      expr.data <- expr.protein\n      expr.data <- rbind(expr.data, annot.protein$symbol)\n      annot.data <- annot.protein\n    }\n    \n    # Remove duplicate columns\n    expr.data <- expr.data[, !duplicated(colnames(expr.data))]\n    \n    \n    \n    # ###########################################\n    # # Allez GSEA\n    # ###########################################\n    # print(\"Performing Allez GSEA...\")\n    # for (i in 1:length(hotspots_genes)) {\n    # \n    #   # Subset expr data to only contain expression for genes in our hotspot.\n    #   filtered_expr_data <- expr.data[,colnames(expr.data) %in% hotspots_genes[[i]]$lodcolumn]\n    #   filtered_expr_data <- as.matrix(filtered_expr_data)\n    #   if (ncol(filtered_expr_data) == 1) {next} # Don't bother making a seperate pipleine for hotspots with only one gene. Not worth.\n    #   \n    #   # Set colnames as gene symbols (gene symbols were stored in the last row) and then remove gene symbols\n    #   colnames(filtered_expr_data) <- filtered_expr_data[nrow(filtered_expr_data),]\n    #   filtered_expr_data <- filtered_expr_data[-190,]\n    #   \n    #   # Some gene symbols map to the same ensemble gene id. Thus we might\n    #   # have some duplicate gene symbols. Delete duplicates for now\n    #   filtered_expr_data <- filtered_expr_data [, !duplicated(colnames(filtered_expr_data ))]\n    #   \n    # \n    #   ##############\n    #   ##############\n    #   # Create vector of t statistics for differential expression with respect to either age or sex (depends on test type)\n    #   if (grepl(\"sex\", test_type)) {covar = annot.sample$Sex} else {covar = annot.sample$Age}\n    # \n    #   score <- vector(length = ncol(filtered_expr_data))\n    #   names(score) <- colnames(filtered_expr_data)\n    #   for (j in 1:ncol(filtered_expr_data)) {\n    #     result <- lm(filtered_expr_data[,j] ~ covar)\n    #     t_val <- tidy(result)[2,4] # Pull out t-statistic\n    #     score[j] <- t_val\n    #   }\n    # \n    #   # Perform enrichment analysis. Save results.\n    #   result_KEGG <- allez(scores = score, lib = \"org.Mm.eg\", sets=\"KEGG\", idtype = \"SYMBOL\")\n    #   result_GO <- allez(scores = score, lib = \"org.Mm.eg\", sets=\"GO\", idtype = \"SYMBOL\")\n    # \n    # \n    #   if (nrow(result_GO$setscores) == 0 && nrow(result_KEGG$setscores) == 0) # If both have nothing in them, skip\n    #   {next}\n    #   else if (nrow(result_GO$setscores) == 0) # If only GO has nothing in it, just use KEGG\n    #   {\n    #     result <- result_KEGG\n    #   }\n    #   else if (nrow(result_KEGG$setscores) == 0) # If only KEGG has nothing in it, just use GO\n    #   {\n    #     result <- result_GO\n    #   } else { # If both are non-empty, concatenate results.\n    #     result <- allezC(result_GO, result_KEGG)\n    #   }\n    #   result_tbl <- allezTable(result) # Get significant categories\n    #   if (nrow(result_tbl) == 0) {print(\"Allez result table has nothing in it!\"); next} # If no significant categories, skip.\n    # \n    #   result_tbl <- allez_helper_func(result_tbl)\n    #   write.csv(result_tbl, file = paste0(output_dir, test_type, \"_\", \"chr\", names(hotspots_genes)[i],\"_\", test_type, \"_hotspot_gsea_tbl_allez.csv\"))\n    # } #for (i in length(hotspot_genes))\n    \n    ###########################################\n    # clusterProfiler GSEA\n    ###########################################\n    print(\"Performing clusterProfiler GSEA...\")\n    for (i in 1:length(hotspots_genes)) {\n      \n      # Subset expr data to only contain expression for genes in our hotspot.\n      filtered_expr_data <- expr.data[,colnames(expr.data) %in% hotspots_genes[[i]]$lodcolumn]\n      filtered_expr_data <- as.matrix(filtered_expr_data)\n      if (ncol(filtered_expr_data) == 1) {next} # Don't bother making a seperate pipleine for hotspots with only one gene. Not worth.\n      \n      # Set colnames as gene symbols (gene symbols were stored in the last row) and then remove gene symbols\n      colnames(filtered_expr_data) <- filtered_expr_data[nrow(filtered_expr_data),]\n      filtered_expr_data <- filtered_expr_data[-190,]\n      \n      # Some gene symbols map to the same ensemble gene id. Thus we might\n      # have some duplicate gene symbols. Delete duplicates for now\n      filtered_expr_data <- filtered_expr_data [, !duplicated(colnames(filtered_expr_data ))]\n      \n      \n      ##############\n      ##############\n      # GO over-representation test needs ENTREZID as input\n      \n      # Create df that maps ENSEMBL, ENTREZ, and symbols to each other.\n      # Contains all genes, not just significant genes. (row 190 of expr data contain gene names.)\n      universe_df <- bitr(as.character(expr.data[190,]),\n                          fromType = \"SYMBOL\",\n                          toType = c(\"ENTREZID\", \"ENSEMBL\"),\n                          OrgDb = org.Mm.eg.db)\n      \n      \n      # Create df that maps ENSEMBL, ENTREZ, and symbols to each other.\n      sig_gene_df <- bitr(as.character(colnames(filtered_expr_data)),\n                          fromType = \"SYMBOL\",\n                          toType = c(\"ENTREZID\", \"ENSEMBL\"),\n                          OrgDb = org.Mm.eg.db)\n      \n      \n      # ###########################################\n      # clusterProfiler Part 1 - GO\n      # ###########################################\n      # \n      # # GO over-representation test\n      go_enrich_output <- enrichGO( gene = sig_gene_df$ENTREZID,\n                                    universe = universe_df$ENTREZID,\n                                    OrgDb = org.Mm.eg.db,\n                                    ont = \"BP\",\n                                    pAdjustMethod = \"BH\",\n                                    pvalueCutoff = 0.05,\n                                    qvalueCutoff = 0.05,\n                                    readable = TRUE)\n      \n      go_result <- go_enrich_output@result\n      write.csv(go_enrich_output, file = paste0(output_dir, test_type, \"_\", qtl_type, \"_\", \"chr\", names(hotspots_genes)[i], \"_hotspot_go_gsea_cluster.csv\"), row.names = FALSE)\n      \n      # ##########################################\n      # clusterProfiler Part 2- KEGG\n      # ##########################################\n      \n      # KEGG over-representation test\n      kegg_enrich_output <- enrichKEGG(gene = sig_gene_df$ENTREZID,\n                                       organism = \"mmu\",\n                                       pvalueCutoff = 0.05)\n      if (nrow(kegg_enrich_output) != 0) {\n        # Save enrich KEGG, but first convert all ENTREZID into symbol for readability.\n        kegg_result <- kegg_enrich_output@result\n        kegg_result$geneID_symbol <- NA\n        for(k in 1:nrow(kegg_result)) {\n          list <- kegg_result$geneID[k]\n          list <- strsplit(list, \"/\")[[1]]\n          list <- as.data.frame(list)\n          list$ENSEMBL <- NA\n          for(n in 1:nrow(list)){\n            list$ENSEMBL[n] <- universe_df[universe_df$ENTREZID %in% list[n,\"list\"],]$SYMBOL[1]\n          }\n          kegg_result$geneID_symbol[k] <- paste(list$ENSEMBL, collapse = \"/\")\n        }\n        write.csv(kegg_result, file = paste0(output_dir, test_type, \"_\", qtl_type, \"_\", \"chr\", names(hotspots_genes)[i], \"_hotspot_kegg_gsea_cluster.csv\"), row.names = FALSE)\n      }\n      \n    } #for (i in length(hotspot_genes))\n  } #for (qtl_type in c(\"cis\", \"trans\")) \n} #for (test_type in c(\"protein_sex\", \"protein_age\", \"protein_none\",\"mrna_sex\", \"mrna_age\", \"mrna_none\")) { \n\n\n\n",
    "created" : 1532291138772.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1663188297",
    "id" : "B42EC3FE",
    "lastKnownWriteTime" : 1532096293,
    "last_content_update" : 1532096293,
    "path" : "~/do_heart/scripts/pipeline/qtls/scans/QTL_hotspots_v4.R",
    "project_path" : "scripts/pipeline/qtls/scans/QTL_hotspots_v4.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}